#!/bin/bash

# 日志
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_line="${timestamp} [MAIN] ${message}"
    echo "${log_line}"
    if [ -n "${TRIM_PKGTMP}" ]; then
        mkdir -p "${TRIM_PKGTMP}"
        echo "${log_line}" >> "${TRIM_PKGTMP}/main.log"
    fi
}

# 基础信息
log_message "==============主程序=============="
log_message "[系统] 运行用户: ${TRIM_RUN_USERNAME:-未设置}"
log_message "[系统] 专用用户: ${TRIM_USERNAME:-未设置}"
log_message "===================================="
log_message "[应用] 名称: ${TRIM_APPNAME:-未设置}"
log_message "[应用] 版本: ${TRIM_APPVER:-未设置}"
log_message "[应用] 状态: ${TRIM_APP_STATUS:-未设置}"
log_message "[应用] 端口: ${TRIM_SERVICE_PORT:-未设置}"
log_message "[应用] 用户: ${TRIM_RUN_USERNAME:-未设置} (UID: ${TRIM_RUN_UID:-未设置})"
log_message "===================================="
log_message "[目录] 执行文件: ${TRIM_APPDEST:-未设置}"
log_message "[目录] 配置文件: ${TRIM_PKGETC:-未设置}"
log_message "[目录] 动态数据: ${TRIM_PKGVAR:-未设置}"
log_message "[目录] 临时文件: ${TRIM_PKGTMP:-未设置}"
log_message "[目录] 用户数据: ${TRIM_PKGHOME:-未设置}"
log_message "[目录] 元数据: ${TRIM_PKGMETA:-未设置}"
log_message "[目录] 存储空间: ${TRIM_APPDEST_VOL:-未设置}"
log_message "[目录] 数据共享: ${TRIM_DATA_SHARE_PATHS:-未设置}"
log_message "[目录] 系统日志文件: ${TRIM_TEMP_LOGFILE:-未设置}"
log_message "[目录] 升级临时: ${TRIM_TEMP_UPGRADE_FOLDER:-未设置}"
log_message "[目录] 安装临时: ${TRIM_PKGINST_TEMP_DIR:-未设置}"
log_message "[目录] FPK解压: ${TRIM_TEMP_TPKFILE:-未设置}"
log_message "===================================="
log_message "[系统] 版本: ${TRIM_SYS_VERSION:-未设置}"
log_message "[系统] 主版本: ${TRIM_SYS_VERSION_MAJOR:-未设置}"
log_message "[系统] 次版本: ${TRIM_SYS_VERSION_MINOR:-未设置}"
log_message "[系统] 构建版本: ${TRIM_SYS_VERSION_BUILD:-未设置}"
log_message "[系统] 架构: ${TRIM_SYS_ARCH:-未设置}"
log_message "[系统] 内核版本: ${TRIM_KERNEL_VERSION:-未设置}"
log_message "[系统] 标识符: ${TRIM_SYS_MACHINE_ID:-未设置}"
log_message "[系统] 语言: ${TRIM_SYS_LANGUAGE:-未设置}"
log_message "===================================="
log_message "==============主程序=============="

LOG_FILE="${TRIM_PKGVAR}/info.log"
PID_FILE="${TRIM_PKGVAR}/app.pid"

APP_BIN="${TRIM_APPDEST}/bin/ammds"

WORK_DIR="${TRIM_APPDEST_VOL}/@appshare/ammds"

PORT="${ammds_app_port}"
PASSWORD="${ammds_admin_password}"

mkdir -p "${WORK_DIR}"
mkdir -p "$(dirname "${LOG_FILE}")"

check_process() {
    local pid="$1"
    kill -0 "${pid}" 2>/dev/null
}

status() {
    if [ -f "${PID_FILE}" ]; then
        local pid
        pid=$(tr -d '[:space:]' < "${PID_FILE}")

        if check_process "${pid}"; then
            log_message "应用程序正在运行 (PID: ${pid})"
            return 0
        else
            log_message "清理过期 PID 文件"
            rm -f "${PID_FILE}"
        fi
    fi
    log_message "应用程序未运行"
    return 3
}

start_process() {
    if status >/dev/null 2>&1; then
        log_message "应用程序已在运行"
        return 0
    fi

    log_message "启动应用程序..."
    log_message "工作目录: ${WORK_DIR}"
    log_message "可执行文件: ${APP_BIN}"

    cd "${WORK_DIR}" || {
        log_message "无法进入工作目录: ${WORK_DIR}"
        return 1
    }

    AMMDS_SERVER_PORT="${PORT}" \
    ADMIN_PASS="${PASSWORD}" \
    "${APP_BIN}" >> "${LOG_FILE}" 2>&1 &

    echo $! > "${PID_FILE}"
    log_message "启动完成，PID: $!"

    return 0
}

stop_process() {
    log_message "停止应用程序..."

    if [ ! -f "${PID_FILE}" ]; then
        log_message "PID 文件不存在"
        return 0
    fi

    local pid
    pid=$(tr -d '[:space:]' < "${PID_FILE}")

    if ! check_process "${pid}"; then
        log_message "进程不存在，清理 PID"
        rm -f "${PID_FILE}"
        return 0
    fi

    log_message "发送 TERM 给 PID ${pid}"
    kill -TERM "${pid}"

    for i in $(seq 1 10); do
        if ! check_process "${pid}"; then
            log_message "进程已结束"
            rm -f "${PID_FILE}"
            return 0
        fi
        log_message "等待进程结束... ${i}/10"
        sleep 1
    done

    log_message "强制杀死 PID ${pid}"
    kill -KILL "${pid}"
    rm -f "${PID_FILE}"

    return 0
}

case $1 in
start)
    # 启动命令。成功退出码0，失败退出码1
    start_process
    ;;
stop)
    # 停止命令。成功退出码0，失败退出码1
    stop_process
    ;;
status)
    # 检查应用状态命令。运行中退出码0，未运行退出码3
    if status; then 
        exit 0
    else 
        exit 3
    fi
    ;;
*)
    log_message "未知命令: $1"
    exit 1
    ;;
esac